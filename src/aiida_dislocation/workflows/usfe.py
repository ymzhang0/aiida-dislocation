from .sfebase import SFEBaseWorkChain
from aiida.common import AttributeDict
from aiida_quantumespresso.workflows.pw.base import PwBaseWorkChain
from aiida import orm
from ase.formula import Formula

class USFEWorkChain(SFEBaseWorkChain):
    """ISFE WorkChain"""

    _SFE_NAMESPACE = "usfe"

    @classmethod
    def define(cls, spec):
        super().define(spec)
        
        spec.exit_code(
            404,
            "ERROR_SUB_PROCESS_FAILED_USF",
            message='The `PwBaseWorkChain` for the USF run failed.',
        )

    def _get_fault_type(self):
        """Return the fault type for USFE workchain."""
        return 'unstable'

    def setup_supercell_kpoints(self):
        """
        Setup kpoints for USFE. 
        Note: current_structure and multiplier are set in should_run_sfe for each iteration.
        """
        fault_type = self._get_fault_type()
        
        # Get unstable fault structure (guaranteed to exist after generate_structures)
        unstable_structure, fault_type_enum = self.ctx.structures.unstable
        
        # Calculate z_ratio for kpoints (need to handle different fault types)
        if fault_type_enum == 'gliding':
            sfe_z_ratio = unstable_structure[0][0].cell.cellpar()[2] / self.ctx.structures.conventional.cell.cellpar()[2]
        elif fault_type_enum == 'removal':
            sfe_z_ratio = unstable_structure[0].cell.cellpar()[2] / self.ctx.structures.conventional.cell.cellpar()[2]
        else:
            raise ValueError(f'Unknown fault type: {fault_type_enum}')
        
        # Get kpoints_scf
        _, kpoints_scf_mesh = self._get_kpoints_scf()
        
        from math import ceil
        
        # Calculate kpoints for SFE
        kpoints_sfe = orm.KpointsData()
        kpoints_sfe.set_kpoints_mesh(kpoints_scf_mesh[:2] + [ceil(kpoints_scf_mesh[2] / sfe_z_ratio)])
        
        # Calculate kpoints for surface energy
        kpoints_surface_energy = orm.KpointsData()
        surface_energy_z_ratio = self.ctx.structures.cleavaged.cell.cellpar()[2] / self.ctx.structures.conventional.cell.cellpar()[2]
        kpoints_surface_energy.set_kpoints_mesh(
            kpoints_scf_mesh[:2] + [ceil(kpoints_scf_mesh[2] / surface_energy_z_ratio)])
        
        self.ctx.kpoints_sfe = kpoints_sfe
        self.ctx.kpoints_surface_energy = kpoints_surface_energy

    def should_run_sfe(self):
        run_sfe = super().should_run_sfe()

        if not run_sfe:
            return False
        
        # Check if unstable fault structure is available (should exist after generate_structures)
        if not hasattr(self.ctx.structures, 'unstable') or self.ctx.structures.unstable is None:
            self.report('Unstable fault structure is not available. Skipping USFE calculation.')
            return False
        
        unstable_structure, fault_type = self.ctx.structures.unstable

        if not unstable_structure:
            return False

        if fault_type == 'gliding':
            self.ctx.fault_type = fault_type
            current_structure_ase, self.ctx.current_burger_vector = unstable_structure.pop()
            self.report(f'The faulted structure is generated by the burger vector: {self.ctx.current_burger_vector}')

        elif fault_type == 'removal':
            self.ctx.fault_type = fault_type
            current_structure_ase, self.ctx.removed_layers = unstable_structure
            self.ctx.structures.unstable = None
            self.report(f'The faulted structure is generated by the removal of the following layers: {self.ctx.removed_layers}')
        
        current_structure = orm.StructureData(
                ase=current_structure_ase
                )
        self.ctx.current_structure = current_structure
        unstable_formula = Formula(current_structure_ase.get_chemical_formula())
        _, unstable_multiplier = unstable_formula.reduce()
        
        self.ctx.unstable_multiplier = unstable_multiplier

        return True
    
    def run_sfe(self):

        inputs = AttributeDict(
            self.exposed_inputs(
                PwBaseWorkChain,
                namespace=self._SFE_NAMESPACE
                )
            )
        inputs.metadata.call_link_label = self._SFE_NAMESPACE

        inputs.pw.structure = self.ctx.current_structure
        inputs.kpoints = self.ctx.kpoints_sfe

        running = self.submit(PwBaseWorkChain, **inputs)
        self.report(f'launching PwBaseWorkChain<{running.pk}> for unstable stacking fault.')

        self.to_context(workchain_sfe = running)

    def inspect_sfe(self):
        workchain = self.ctx.workchain_sfe

        if not workchain.is_finished_ok:
            self.report(
                f"PwBaseWorkChain<{workchain.pk}> for unstable faulted geometry failed with exit status {workchain.exit_status}"
            )
            return self.exit_codes.ERROR_SUB_PROCESS_FAILED_USF

        self.report(
            f'PwBaseWorkChain<{workchain.pk}> for unstable faulted geometry finished OK'
            )
        self.out_many(
            self.exposed_outputs(
                workchain,
                PwBaseWorkChain,
                namespace=self._SFE_NAMESPACE,
            ),    
        )

        self.ctx.total_energy_usf_geometry = self.ctx.total_energy_faulted_geometry = workchain.outputs.output_parameters.get('energy')
        self.report(f'Total energy of unstable faulted geometry [{self.ctx.unstable_multiplier} unit cells]: {self.ctx.total_energy_usf_geometry / self._RY2eV} Ry')
        
        if 'total_energy_conventional_geometry' in self.ctx:
            energy_difference = self.ctx.total_energy_usf_geometry - self.ctx.total_energy_conventional_geometry / self.ctx.conventional_multiplier * self.ctx.unstable_multiplier
            unstable_stacking_fault_energy = energy_difference / self.ctx.surface_area * self._eVA22Jm2
            self.report(f'unstable stacking fault energy of evaluated from conventional geometry: {unstable_stacking_fault_energy} J/m^2')
